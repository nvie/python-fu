#!/usr/bin/env python
from __future__ import absolute_import

import sys
import os
import re
import argparse


module_name_re = re.compile('^[a-zA-Z_][a-zA-Z0-9_]*$')


def valid_module_name(module_name):
    return module_name_re.match(module_name)


def valid_module_path(module):
    components = module.split('.')
    return all([valid_module_name(comp) for comp in components])


class Module(object):
    ##
    # Constructors
    @classmethod
    def from_file(cls, file_path):
        raise NotImplementedError('not yet implemented')

    @classmethod
    def from_module_path(cls, module_path):
        components = module_path.split('.')
        return cls(components)

    def __init__(self, components):
        assert isinstance(components, list), \
            'Constructor only takes list of module names, not %s' % (components,)
        self.components = components

    @property
    def parents(self):
        if len(self.components) <= 1:
            return []
        return self.components[:-1]

    @property
    def module_name(self):
        return self.components[-1]

    def split(self):
        return (self.parents, self.module_name)

    @property
    def module_file(self):
        parents, last = self.split()
        return os.path.join(*parents + [last + '.py'])

    @property
    def package_file(self):
        parents, last = self.split()
        return os.path.join(*parents + [os.path.join(last, '__init__.py')])

    def is_package(self):
        return os.path.isfile(self.package_file)

    def is_module(self):
        return os.path.isfile(self.module_file)


    ##
    # Self-printing
    def __unicode__(self):  # noqa
        return u'Module %s' % (u'.'.join(self.components,))

    def __repr__(self):
        return 'Module(%r)' % (self.components,)

    def __str__(self):
        return unicode(self).encode('utf-8')


def replace_extension(filename, new_extension):
    filename, ext = filename.rsplit('.', 1)
    return '.'.join([filename, new_extension])


def parse_args():
    parser = argparse.ArgumentParser(
            description='Promotes Python modules to packages.')
    parser.add_argument('modules', nargs='+')
    return parser.parse_args()


def info(msg):
    sys.stdout.write("%s\n" % (msg,))
    sys.stdout.flush()


def error(msg):
    sys.stderr.write("%s\n" % (msg,))
    sys.stderr.flush()


warning = error


def exit(msg, exitcode=1):
    error("%s\n" % (msg,))
    sys.exit(exitcode)


def main():
    args = parse_args()

    # Sanity check first
    for module_path in args.modules:
        if not valid_module_path(module_path):
            exit('Invalid module path: %s' % (module_path,))

    for module_path in args.modules:
        module = Module.from_module_path(module_path)

        if module.is_package():
            warning('%s is a package already, skipping.' % (module,))
            continue
        elif not module.is_module():
            warning('%s does not exist, skipping.' % (module,))
            continue

        module_file = module.module_file
        package_file = module.package_file

        #info('Found %s' % (module_file,))
        info('Moving %s -> %s' % (module_file, package_file))
        os.renames(module_file, package_file)

        compiled_extensions = ['pyo', 'pyc']
        for ext in compiled_extensions:
            filename = replace_extension(module_file, ext)
            if os.path.isfile(filename):
                info('Cleaning up compiled module file %s' % (filename,))
                os.remove(filename)


if __name__ == '__main__':
    main()
